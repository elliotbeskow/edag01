        -:    0:Source:intopt.c
        -:    0:Graph:intopt.gcno
        -:    0:Data:intopt.gcda
        -:    0:Runs:1
        -:    1:#include <bits/types/sigset_t.h>
        -:    2:#include <endian.h>
        -:    3:# include <stdio.h>
        -:    4:# include <stdlib.h>
        -:    5:# include <math.h>
        -:    6:
        -:    7:#define eps 1e-6
        -:    8:
        -:    9:
        -:   10:struct simplex_t
        -:   11:{
        -:   12:	int     m;
        -:   13:	int     n;
        -:   14:	int     *var;
        -:   15:	double  **a;
        -:   16:	double  *b;
        -:   17:	double  *x;
        -:   18:	double  *c;
        -:   19:	double  y;
        -:   20:};
        -:   21:
        -:   22:struct node_t
        -:   23:{
        -:   24:	int m;
        -:   25:	int n;
        -:   26:	int k;
        -:   27:	int h;
        -:   28:	double xh;
        -:   29:	double ak;
        -:   30:	double bk;
        -:   31:	double *min;
        -:   32:	double *max;
        -:   33:	double **a;
        -:   34:	double *b;
        -:   35:	double *x;
        -:   36:	double *c;
        -:   37:	double z;
        -:   38:};
        -:   39:
        -:   40:struct set_t
        -:   41:{
        -:   42:	int size;
        -:   43:	struct node_t **nodes;
        -:   44:};
        -:   45:
        -:   46:int initial(struct simplex_t *s, int m, int n, double **a, double *b, double *c, double *x, double y, int *var);
        -:   47:void pop(struct set_t *h);
function init called 44550 returned 100% blocks executed 100%
    44550:   48:int init(struct simplex_t *s, int m, int n, double **a, double *b, double *c, double *x, double y, int* var)
        -:   49:{
        -:   50:	int i, k;
    44550:   51:	s->m = m;
    44550:   52:	s->n = n;
    44550:   53:	s->a = a;
    44550:   54:	s->b = b;
    44550:   55:	s->c = c;
    44550:   56:	s->x = x;
    44550:   57:	s->y = y;
    44550:   58:	s->var = var; 
    44550:   59:	if (s->var == NULL)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   60:	{
    22285:   61:		s->var = malloc((m+n+1)*sizeof(int));
  1165337:   62:		for (i = 0; i<m+n; i++)
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
  1143052:   63:			s->var[i] = i;
        -:   64:	}
  1394191:   65:	for (k = 0, i = 1; i < m; i++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  1349641:   66:		if (b[i] < b[k])
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
   228766:   67:			k = i;
    44550:   68:	return k;
        -:   69:}
        -:   70:
function select_nonbasic called 1038914 returned 100% blocks executed 100%
  1038914:   71:int select_nonbasic(struct simplex_t *s)
        -:   72:{
        -:   73:	int i;
  8021162:   74:	for (i = 0; i<s->n; i = i + 1)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  7980800:   75:		if (s->c[i] > eps)
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
   998552:   76:			return i;
    40362:   77:	return -1;
        -:   78:}
        -:   79:
function pivot called 1035768 returned 100% blocks executed 100%
  1035768:   80:void pivot(struct simplex_t *s, int row, int col)
        -:   81:{
  1035768:   82:	double **a = s->a;
  1035768:   83:	double *b = s->b;
  1035768:   84:	double *c = s->c;
  1035768:   85:	int m = s->m;
  1035768:   86:	int n = s->n;
        -:   87:	int i, j, t;
  1035768:   88:	t = s->var[col];
  1035768:   89:	s->var[col] = s->var[n + row];
  1035768:   90:	s->var[n + row] = t;
  1035768:   91:	s->y = s->y + c[col] * b[row] / a[row][col];
 22497822:   92:	for (i = 0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
 21462054:   93:		if (i != col)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
 20426286:   94:			c[i] = c[i] - c[col] * a[row][i] / a[row][col];
  1035768:   95:	c[col] = -c[col]/a[row][col];
 33702002:   96:	for (i=0; i < m; i = i + 1)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
 32666234:   97:		if (i != row)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
 31630466:   98:			b[i] = b[i] - a[i][col] * b[row] / a[row][col];
 33702002:   99:	for (i = 0; i < m; i = i + 1)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
 32666234:  100:		if (i != row)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
687148070:  101:			for (j = 0; j < n; j++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
655517604:  102:				if (j != col)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
623887138:  103:					a[i][j] = a[i][j] - a[i][col] * a[row][j] / a[row][col];
 33702002:  104:	for (i=0; i<m; i++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
 32666234:  105:		if (i != row)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
 31630466:  106:			a[i][col] = -a[i][col]/a[row][col];
 22497822:  107:	for (i = 0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
 21462054:  108:		if (i !=col)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
 20426286:  109:			a[row][i] = a[row][i] / a[row][col];
  1035768:  110:	b[row] = b[row] / a[row][col];
  1035768:  111:	a[row][col] = 1 / a[row][col];
  1035768:  112:}
        -:  113:
function prepare called 22265 returned 100% blocks executed 100%
    22265:  114:void prepare(struct simplex_t *s, int k)
        -:  115:{
    22265:  116:	int m = s->m;
    22265:  117:	int n = s->n;
        -:  118:	int i;
        -:  119:	// make room for x_(m+n) at s.var[n] by moving s.var[n, ..., n+m-1] one step to the right.
   719104:  120:	for (i = m + n; i > n; i = i - 1)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   696839:  121:		s->var[i] = s->var[i-1];
    22265:  122:	s->var[n] = m + n;
        -:  123:	// add x_(m+n) to each constraint
    22265:  124:	n += 1;
   719104:  125:	for (i = 0; i < m; i = i + 1)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   696839:  126:		s->a[i][n-1] = -1;
    22265:  127:	s->x = calloc(m + n, sizeof(double));
    22265:  128:	s->c = calloc(n, sizeof(double));
    22265:  129:	s->c[n-1] = -1;
    22265:  130:	s->n = n;
    22265:  131:	pivot(s, k, n-1);
call    0 returned 100%
    22265:  132:}
        -:  133:
        -:  134:
function xsimplex called 44550 returned 100% blocks executed 97%
    44550:  135:double xsimplex(int m, int n, double **a, double *b, double *c, double *x, double y, int *var, int h)
        -:  136:{
        -:  137:	struct simplex_t s;
        -:  138:	int i, row, col;
    44550:  139:	if (!initial(&s, m, n, a, b, c, x, y, var)) {
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
     4188:  140:		free(s.var);
     4188:  141:		s.var = NULL;
     4188:  142:		return NAN;
        -:  143:	}
  1038914:  144:	while ((col = select_nonbasic(&s)) >= 0) {
call    0 returned 100%
branch  1 taken 96%
branch  2 taken 4% (fallthrough)
   998552:  145:		row = -1;
 32498199:  146:		for (i = 0; i < m; i = i + 1)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
 31499647:  147:			if ((a[i][col] > eps) && ((row < 0) || (b[i]/a[i][col]<b[row]/a[row][col])))
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
branch  4 taken 16% (fallthrough)
branch  5 taken 84%
  3528033:  148:				row = i;
   998552:  149:		if (row < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  150:		{
    #####:  151:			free(s.var);
    #####:  152:			s.var = NULL;
    #####:  153:			return INFINITY;
        -:  154:		}
   998552:  155:		pivot(&s, row, col);
call    0 returned 100%
        -:  156:	}
    40362:  157:	if (h == 0)
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
        -:  158:	{
   380037:  159:		for (i = 0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   361940:  160:			if (s.var[i] < n)
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
   139401:  161:				x[s.var[i]] = 0;
   580570:  162:		for (i = 0; i < m; i++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   562473:  163:			if (s.var[i+n] < n)
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
   222539:  164:				x[s.var[n+i]] = s.b[i];
    18097:  165:		free(s.var);
    18097:  166:		s.var = NULL;
        -:  167:	}
        -:  168:	else {
   489830:  169:		for (i = 0; i < n; i = i + 1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   467565:  170:			x[i] = 0;
   719104:  171:		for (i = n; i< n + m; i = i + 1)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   696839:  172:			x[i] = s.b[i-n];
        -:  173:	}
        -:  174:	//printf("%lf %lf", x[0], x[1]);
        -:  175:	//printf("%lf %lf", s.x[0], s.x[1]);
    40362:  176:	return s.y;
        -:  177:}
        -:  178:
function initial called 44550 returned 100% blocks executed 100%
    44550:  179:int initial(struct simplex_t *s, int m, int n, double **a, double *b, double *c, double *x, double y, int *var)
        -:  180:{
        -:  181:	int i, j, k;
        -:  182:	double w;
    44550:  183:	k = init(s, m, n, a, b, c, x, y, var);
call    0 returned 100%
    44550:  184:	if (b[k] >= 0)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    22285:  185:		return 1;
    22265:  186:	prepare(s, k);
call    0 returned 100%
    22265:  187:	n = s->n;
    22265:  188:	s->y = xsimplex(m, n, s->a, s->b, s->c, s->x, 0, s->var, 1);
call    0 returned 100%
   911734:  189:	for (i=0; i < m + n; i++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   911734:  190:		if (s->var[i] == m + n - 1){
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    22265:  191:			if (fabs(s->x[i])>eps) {
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
     4188:  192:				free(s->x);
     4188:  193:				s->x = NULL;
     4188:  194:				free(s->c);
     4188:  195:				s->c = NULL;
     4188:  196:				return 0;
        -:  197:			} else {
    18077:  198:				break;
        -:  199:			}
        -:  200:		}
    18077:  201:	if (i >= n) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  202:		// x[n+m] is basic. find good nonbasic.
   328922:  203:		for (j = k = 0; k < n; k++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   313971:  204:			if (fabs(s->a[i-n][k]) > fabs(s->a[i-n][j])) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
    30556:  205:				j = k;
        -:  206:			}
    14951:  207:		pivot(s, i-n, j);
call    0 returned 100%
    14951:  208:		i = j;
        -:  209:	}
    18077:  210:	if (i<n-1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  211:		// x[n+m] is nonbasic and not last. swap columns i and n-1
    18068:  212:		k = s->var[i]; s->var[i] = s->var[n-1]; s->var[n-1] = k;
   579746:  213:		for (k = 0; k < m; k = k + 1) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   561678:  214:			w = s->a[k][n-1]; s->a[k][n-1] = s->a[k][i]; s->a[k][i] = w;
        -:  215:		}
        -:  216:	}
    18077:  217:	free(s->c);
    18077:  218:	s->c = c;
    18077:  219:	s->y = y;
   580037:  220:	for (k = n-1; k < n + m - 1; k++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   561960:  221:		s->var[k] = s->var[k+1];
    18077:  222:	n = s->n = s->n - 1;
    18077:  223:	double *t = calloc(n, sizeof(double));
   379617:  224:	for (k = 0; k < n; k++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  6212241:  225:		for (j = 0; j < n; j++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  6021371:  226:			if (k ==s->var[j]) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  227:				// x[k] is nonbasic, add c[k]
   170670:  228:				t[j] = t[j] + s->c[k];
   170670:  229:				goto next_k;
        -:  230:			}
        -:  231:		}
  3246448:  232:		for (j = 0; j < m; j++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
  3246448:  233:			if (s->var[n+j] == k) break;
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  234:
        -:  235:		}
   190870:  236:		s->y = s->y + s->c[k] * s->b[j];
  4008270:  237:		for (i = 0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  3817400:  238:			t[i] = t[i] - s->c[k] * s->a[j][i];
   361540:  239:next_k:;
        -:  240:	}
   379617:  241:	for (i=0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   361540:  242:		s->c[i] = t[i];
    18077:  243:	free(t);
    18077:  244:	free(s->x);
    18077:  245:	t = NULL;
    18077:  246:	s->x = NULL;
    18077:  247:	return 1;
        -:  248:}
        -:  249:
function simplex called 22285 returned 100% blocks executed 100%
    22285:  250:double simplex(int m, int n, double **a, double *b, double *c, double *x, double y)
        -:  251:{
    22285:  252:	return xsimplex(m, n, a, b, c, x, y, NULL, 0);
call    0 returned 100%
        -:  253:}
        -:  254:
function initial_node called 1 returned 100% blocks executed 100%
        1:  255:struct node_t *initial_node(int m, int n, double **a, double *b, double *c)
        -:  256:{
        -:  257:	int i, j;
        1:  258:	struct node_t *p = calloc(1, sizeof(struct node_t));
        1:  259:	p->a = calloc(m + 1, sizeof(double*));
       22:  260:	for (i=0; i<m+1; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       21:  261:		p->a[i] = calloc(n+1, sizeof(double));
        -:  262:	} 
        1:  263:	p->b = calloc(m + 1, sizeof(double));
        1:  264:	p->c = calloc(n + 1, sizeof(double));
        1:  265:	p->x = calloc(m + n + 1, sizeof(double));
        1:  266:	p->min = calloc(n, sizeof(double));
        1:  267:	p->max = calloc(n, sizeof(double));
        1:  268:	p->m = m;
        1:  269:	p->n = n;
        -:  270:	// it might be that the following loops should go to i<n, i<m.
       21:  271:	for (i = 0; i<n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      420:  272:		for (j = 0; j<m; j++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      400:  273:			p->a[j][i] = a[j][i];
       20:  274:		p->c[i] = c[i];
        -:  275:	}
       21:  276:	for (i = 0; i<m; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  277:		p->b[i] = b[i];
       21:  278:	for (i=0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  279:	{
       20:  280:		p->min[i] = -INFINITY; 
       20:  281:		p->max[i] = INFINITY;
        -:  282:	}
        1:  283:	return p;
        -:  284:}
        -:  285:
function extend called 22284 returned 100% blocks executed 100%
    22284:  286:struct node_t *extend(struct node_t *p, int m, int n, double **a, double *b, double *c, int k, double ak, double bk)
        -:  287:{
    22284:  288:	struct node_t *q = calloc(1, sizeof(struct node_t));
        -:  289:	int i, j;
    22284:  290:	q->k = k;
    22284:  291:	q->ak = ak;
    22284:  292:	q->bk = bk;
    22284:  293:	if (ak > 0 && p->max[k] < INFINITY)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 27% (fallthrough)
branch  3 taken 73%
     2974:  294:		q->m = p->m;
    19310:  295:	else if (ak < 0 && p->min[k] > 0)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
     2928:  296:		q->m = p->m;
        -:  297:	else
    16382:  298:		q->m = p->m + 1;
    22284:  299:	q->n = p->n;
    22284:  300:	q->h = -1;
    22284:  301:	q->a = calloc(q->m + 1, sizeof(double*));
   741900:  302:	for (i=0; i < q->m + 1; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   719616:  303:		q->a[i] = calloc(q->n + 1, sizeof(double));
        -:  304:	}
    22284:  305:	q->b = calloc(q->m + 1, sizeof(double));
    22284:  306:	q->c = calloc(q->n + 1, sizeof(double));
    22284:  307:	q->x = calloc(q->n + 1, sizeof(double));
    22284:  308:	q->min = calloc(n, sizeof(double));
    22284:  309:	q->max = calloc(n, sizeof(double));
   467964:  310:	for (i = 0; i<n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   445680:  311:		q->min[i] = p->min[i];
   445680:  312:		q->max[i] = p->max[i];
   445680:  313:		q->c[i] = c[i];
        -:  314:	}
   467964:  315:	for (i=0; i<m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  9359280:  316:		for (j=0; j<n; j++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  8913600:  317:			q->a[i][j] = a[i][j];
   445680:  318:		q->b[i] = b[i];
        -:  319:	}
    22284:  320:	if (ak > 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    11142:  321:		if ((q->max[k] == INFINITY) || (bk < q->max[k]))
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    11142:  322:			q->max[k] = bk;
    11142:  323:	} else if ((q->min[k] == -INFINITY) || (-bk > q->min[k])) {
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    11142:  324:		q->min[k] = -bk;
        -:  325:	}
   467964:  326:	for (i = m, j = 0; j < n; j++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   445680:  327:		if (q->min[j] > -INFINITY) {
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
   105810:  328:			q->a[i][j] = -1;
   105810:  329:			q->b[i] = -q->min[j];
   105810:  330:			i++;
        -:  331:		}
   445680:  332:		if (q->max[j] < INFINITY) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
   145842:  333:			q->a[i][j] = 1;
   145842:  334:			q->b[i] = q->max[j];
   145842:  335:			i++;
        -:  336:		}
        -:  337:	}
    22284:  338:	return q;
        -:  339:}
        -:  340:
function is_integer called 251524 returned 100% blocks executed 100%
   251524:  341:int is_integer(double *xp)
        -:  342:{
   251524:  343:	double x = *xp;
   251524:  344:	double r = lround(x);
   251524:  345:	if (fabs(r-x) < eps) {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
   220791:  346:		*xp = r;
   220791:  347:		return 1;
        -:  348:	}
    30733:  349:	return 0;
        -:  350:}
        -:  351:
function integer called 18097 returned 100% blocks executed 100%
    18097:  352:int integer(struct node_t *p)
        -:  353:{
   147924:  354:	for (int i = 0; i<p->n; i++)
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
   147912:  355:		if (!is_integer(&(p->x[i])))
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
    18085:  356:			return 0;
       12:  357:	return 1;
        -:  358:}
        -:  359:
function free_node called 22285 returned 100% blocks executed 100%
    22285:  360:void free_node(struct node_t *p)
        -:  361:{
    22285:  362:	if (p->a!=NULL){
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
   329316:  363:		for (int i = 0; i < p->m+1; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   319679:  364:			free(p->a[i]);
        -:  365:		}
     9637:  366:		free(p->a);
        -:  367:	}
    22285:  368:	if (p->b!=NULL)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
     9637:  369:		free(p->b);
    22285:  370:	if (p->c!=NULL)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
     9637:  371:		free(p->c);
    22285:  372:	if (p->x!=NULL)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
     9637:  373:		free(p->x);
    22285:  374:	free(p->min);
    22285:  375:	free(p->max);
    22285:  376:	free(p);
    22285:  377:}
        -:  378:
function bound called 12 returned 100% blocks executed 100%
       12:  379:void bound(struct node_t *p, struct set_t *h, double *zp, double *x, int n)
        -:  380:{
        -:  381:	int i;
       12:  382:	if (p->z > *zp) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        5:  383:		*zp = p->z;
      105:  384:		for (i = 0; i < n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      100:  385:			x[i] = p->x[i];
     3379:  386:		for (i = 0; i < h->size; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     3374:  387:			if (h->nodes[i]->z < p->z) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
     1506:  388:				free_node(h->nodes[i]);
call    0 returned 100%
  1459514:  389:				for (int j = i; j<h->size-1; j++)
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
  1458008:  390:					h->nodes[j] = h->nodes[j+1];
     1506:  391:        h->size--;
     1506:  392:        h->nodes = realloc(h->nodes, h-> size * sizeof(struct node_t *));
        -:  393:				//free(h->nodes[h->size]);
        -:  394:			} 
        -:  395:		}
        -:  396:	}
       12:  397:}
        -:  398:
function branch called 18085 returned 100% blocks executed 89%
    18085:  399:int branch(struct node_t *q, double z) {
        -:  400:	double min, max;
    18085:  401:	if (q->z < z)
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
     5437:  402:		return 0;
   103612:  403:	for (int h=0; h<q->n; h = h + 1) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   103612:  404:		if (!is_integer(&(q->x[h]))) {
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
    12648:  405:			if (q->min[h] == -INFINITY)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
     9184:  406:				min = 0;
        -:  407:			else
     3464:  408:				min = q->min[h];
    12648:  409:			max = q->max[h];
    12648:  410:			if (floor(q->x[h]) < min || ceil(q->x[h]) > max)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  411:				continue;
    12648:  412:			q->h = h;
    12648:  413:			q->xh = q->x[h];
   278256:  414:			for (int i=0; i<q->n+1; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   265608:  415:				free(q->a[i]);
        -:  416:			}
    12648:  417:			free(q->a);
    12648:  418:			free(q->b);
    12648:  419:			free(q->c);
    12648:  420:			free(q->x);
    12648:  421:			q->a = NULL;
    12648:  422:			q->b = NULL;
    12648:  423:			q->c = NULL;
    12648:  424:			q->x = NULL;
    12648:  425:			return 1;
        -:  426:		}
        -:  427:	}
    #####:  428:	return 0;
        -:  429:}
        -:  430:
function succ called 22284 returned 100% blocks executed 94%
    22284:  431:void succ(struct node_t *p, struct set_t *h, int m, int n, double **a, double *b, double *c, int k, double ak, double bk, double *zp, double *x) {
    22284:  432:	struct node_t *q = extend(p, m, n, a, b, c, k, ak, bk);
call    0 returned 100%
    22284:  433:	if (q==NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  434:		return;
    22284:  435:	q->z = simplex(q->m, q->n, q->a, q->b, q->c, q->x, 0);
call    0 returned 100%
    22284:  436:	if (isfinite(q->z)) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
    18096:  437:		if(integer(q)){
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       12:  438:			bound(q, h, zp, x, n);
call    0 returned 100%
    18084:  439:		} else if (branch(q, *zp)) {
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30%
    12647:  440:			h->size++;
    12647:  441:			struct node_t **new_array = calloc(h->size, sizeof(struct node_t*));
 15139568:  442:			for (int i = 1; i<h->size; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
 15126921:  443:				new_array[i] = h->nodes[i-1];
        -:  444:			}
    12647:  445:			new_array[0] = q;
        -:  446:			//free(h->nodes);
    12647:  447:			h->nodes = new_array;
        -:  448:			//free(new_array);
    12647:  449:			return;
        -:  450:		}
        -:  451:	}
     9637:  452:	free_node(q);
call    0 returned 100%
     9637:  453:	q = NULL;
        -:  454:}
        -:  455:
function intopt called 1 returned 100% blocks executed 68%
        1:  456:double intopt(int m, int n, double **a, double *b, double *c, double *x) {
        1:  457:	struct node_t *p = initial_node(m, n, a, b, c);
call    0 returned 100%
        1:  458:	struct set_t h = {1,&p};
        1:  459:	double z = -INFINITY;
        1:  460:	p->z = simplex(p->m, p->n, p->a, p->b, p->c, p->x, 0);
call    0 returned 100%
        1:  461:	if (integer(p) || !isfinite(p->z)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  462:		z = p->z;
    #####:  463:		if (integer(p)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  464:			for (int i=0; i<n; i++)
branch  0 never executed
branch  1 never executed
    #####:  465:				x[i] = p->x[i];
        -:  466:		}
    #####:  467:		free_node(p);
call    0 never executed
    #####:  468:		return z;
        -:  469:	}
        1:  470:	branch(p, z);
call    0 returned 100%
    11143:  471:	while (h.size) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
        -:  472:		//printf("z = %lf \n", z);
    11142:  473:		struct node_t *q = h.nodes[h.size-1];
    11142:  474:    h.size--;
    11142:  475:    if (h.size > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    11140:  476:      h.nodes = realloc(h.nodes, h. size * sizeof(struct node_t *));
        -:  477:    }
        -:  478:    
    11142:  479:		succ(q, &h, m, n, a, b, c, q->h, 1, floor(q->xh), &z, x);
call    0 returned 100%
    11142:  480:		succ(q, &h, m, n, a, b, c, q->h, -1, -ceil(q->xh), &z, x);
call    0 returned 100%
    11142:  481:    free_node(q);
call    0 returned 100%
        -:  482:	}
        1:  483:	if (z == -INFINITY)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  484:		return NAN;
        -:  485:	else
        1:  486:		return z;
        -:  487:}
        -:  488:
function main called 1 returned 100% blocks executed 100%
        1:  489:int main(void)
        -:  490:{
        -:  491:	int m;
        -:  492:	int n;
        -:  493:	double** a;
        -:  494:	double* b;
        -:  495:	double* c;
        1:  496:	scanf("%d %d", &m, &n);
call    0 returned 100%
        1:  497:	a = calloc(m, sizeof(double*));
       21:  498:	for(int i=0; i<m; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  499:		a[i] = calloc(n, sizeof(double));
        1:  500:	b = calloc(m, sizeof(double));
        1:  501:	c = calloc(n, sizeof(double));
       21:  502:	for(int i=0; i<n; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  503:		scanf("%lf", &c[i]);
call    0 returned 100%
       21:  504:	for(int i=0; i<m; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  505:	{
      420:  506:		for(int j=0; j<n; j+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      400:  507:			scanf("%lf", &a[i][j]);
call    0 returned 100%
        -:  508:	}
       21:  509:	for(int i=0; i<m; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  510:		scanf("%lf", &b[i]);
call    0 returned 100%
        1:  511:	printf("LINEAR PROGRAM (m=%d n=%d)\n", m, n); 
call    0 returned 100%
        1:  512:	printf("--------------------------\n\n");
call    0 returned 100%
        1:  513:	printf("max z = %lfx_0", c[0]);
call    0 returned 100%
       20:  514:	for(int i=1; i<n; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       19:  515:		printf(" + %lfx_%d", c[i], i);
call    0 returned 100%
        1:  516:	printf("\n");
call    0 returned 100%
       21:  517:	for(int i=0; i<m; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  518:	{
       20:  519:		printf("%lfx_0", a[i][0]);
call    0 returned 100%
      400:  520:		for (int j=1; j<n; j+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      380:  521:			printf(" + %lfx_%d", a[i][j], j);
call    0 returned 100%
       20:  522:		printf("<= %lf\n", b[i]);            
call    0 returned 100%
        -:  523:	}
        1:  524:	printf("x_0, ..., x_%d >= 0\n", n-1);
call    0 returned 100%
        1:  525:	double *x = calloc(n, sizeof(double));
       21:  526:	for (int i=0; i<n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  527:		x[i] = 0;
        1:  528:	double y = 0;       
        1:  529:	printf("Solution y=%lf\n", intopt(m, n, a, b, c, x));
call    0 returned 100%
call    1 returned 100%
       21:  530:	for (int i=0; i<n; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  531:		printf("%lf, ", x[i]);
call    0 returned 100%
       21:  532:	for(int i=0; i<m; i+=1)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  533:		free(a[i]);
        1:  534:	free(a); free(b); free(c); free(x);
        1:  535:	return 0;
        -:  536:}
        -:  537:
